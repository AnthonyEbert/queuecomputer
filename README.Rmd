
---
output: github_document
---

<!-- --- -->
<!-- output: html -->
<!-- bibliography: references.bib -->
<!-- --- -->

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, echo = FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  collapse = TRUE,
  comment = "#>",
  fig.path = "README-"
)
```


$$ $$

# Install

```{r, eval = FALSE}
devtools::install_github("AnthonyEbert/queuecomputer")
library(queuecomputer)
```

```{r messages = FALSE, error = FALSE, echo = FALSE}
devtools::load_all()
```

# Why more queueing software?

<!-- There is already a lot of queueing simulation packages out there including the following R packages:  -->

<!-- * [```liqueueR```](https://cran.r-project.org/web/packages/liqueueR/index.html), -->
<!-- * [```queueing```](https://cran.r-project.org/web/packages/queueing/index.html), -->
<!-- * [```rstackdeque```](https://cran.r-project.org/web/packages/rstackdeque/index.html) & -->
<!-- * [```simmer```](http://r-simmer.org/). -->

<!-- ```liqueueR``` is written for priority queues. ```queueing ``` simulates well known simple queues such as M/M/1. -->

<!-- Python packages: -->

<!-- * [```queue-lib```](https://pypi.python.org/pypi/queuelib) -->
<!-- * [```simpy```](https://simpy.readthedocs.io/en/latest/) -->

<!-- Matlab / Octave packages: -->

<!-- * [```queueing```](http://www.moreno.marzolla.name/software/queueing/) -->

`queuecomputer` is an R package for simulating queueing networks. 

We've developed a more computationally efficient algorithm for simulating First-in-first-out queues and built this into an R package called `queuecomputer`. The current most popular method for simulating queues is Discete Event Simulation (DES). The top R package for DES is called `simmer` and the top Python package is called `SimPy`. We have validated and benchmarked queuecomputer against both these packages and found that queuecomputer is two orders of magnitude faster than either package. 

The focus of this package is on <b>queue computation</b> rather than <b>queue simulation</b>. Existing queue simulation software are highly constrained in arrival distributions, this package decouples sampling and queue computation to free the user to specify any arrival or service process. 

This package was inspired by the problem of modelling passenger flows through an international airport terminal. Batch arrivals (planes) occur throughout the day at scheduled times with delays at different parts of the airport. A completely flexible queueing framework is needed to allow for arbitrary arrival and service distributions (with dependencies) and resource schedules. An efficient computation engine is needed to allow for Bayesian sampling. 

Simulating arbitrary queues is difficult, however once:

1. The arrival times $t^a$ and service times $s$ are known for all customers and,
2. the server resource schedule is specified

then the departure times $t^d$ for all customers can be computed exactly. 

The focus on this package is:

* fast computation of departure times given arrival and service times, and
* a flexible framework to allow for extensions such as server effects.



It is up to the user to provide arrival and service times, and therefore very complicated distributions can be simulated (by the user) and tested with this package. 


# Example

In this example the arrival process is log-normal and the service times are log-normal. We compare two different queue scenarios, the first `firstqueue` with a single server throughout the day and the second `secondqueue` with 1 server until time 15, 3 servers from time 15 to time 30, 1 server from time 30 to time 50 and 10 servers from there onwards. 

```{r}
library(ggplot2)
library(reshape2)
library(magrittr)
library(iterators)

set.seed(700)
arrival_df <- data.frame(ID = c(1:100), times = rlnorm(100, meanlog = 3))
service <- rlnorm(100)
server_list <- as.server.step(c(15,30,50),c(1,3,1,10))

firstqueue <- queue_step(arrival_df = arrival_df, service = service)
secondqueue <- queue_step(arrival_df = arrival_df,
    servers = server_list, service = service)
```

## Print secondqueue output ordered by arrival times

```{r}
ord <- order(arrival_df$times)

first_queueoutput <- data.frame(ID = arrival_df$ID[ord], arrivals = arrival_df$times[ord], service = service[ord],
    departure = firstqueue$times[ord])

second_queueoutput <- data.frame(ID = arrival_df$ID[ord], arrivals = arrival_df$times[ord], service = service[ord],
    departure = secondqueue$times[ord])

second_queueoutput[1:50,]
```

## Plot customers arrived and customers served

```{r}

curve(ecdf(arrival_df$times)(x) * 100 , from = 0, to = 200,
    xlab = "time", ylab = "Number of customers")
curve(ecdf(firstqueue$times)(x) * 100 , add = TRUE, col = "red")
curve(ecdf(secondqueue$times)(x) * 100, add = TRUE, col = "blue")
legend(100,40, legend = c("Customer input - arrivals",
    "Customer output - firstqueue",
    "Customer output - secondqueue"),
    col = c("black","red","blue"), lwd = 1, cex = 0.8
)

```

## Plot densities

```{r}
departure_df <- data.frame(arrival_times = arrival_df$times, 
  firstqueue_departuretimes = firstqueue$times, 
  secondqueue_departuretimes = secondqueue$times) %>% reshape2::melt()

qplot(value, data = departure_df, colour = variable, geom = "density") + xlab("time")
```

## Plot queue lengths

```{r}
#queue lengths ------------

ecdf_df <- data.frame(time = c(1:200), 
  firstqueue = ecdf(arrival_df$times)(c(1:200)) * 100 - 
    ecdf(firstqueue$times)(c(1:200))*100, 
  secondqueue = ecdf(arrival_df$times)(c(1:200))*100 - 
    ecdf(secondqueue$times)(c(1:200))*100) %>% reshape2::melt(id.vars = "time")

head(ecdf_df)

qplot(time, value, data = ecdf_df, colour = variable, geom = "step") + xlab("time") + ylab("queue length")
```

## Summary statistics

```{r}
first_waiting_time <- (first_queueoutput$departure - first_queueoutput$service - first_queueoutput$arrival)
second_waiting_time <- (second_queueoutput$departure - second_queueoutput$service - second_queueoutput$arrival)

first_waiting_time %>% summary
second_waiting_time %>% summary
```

## How long does it take?

Let's try a big queue with one million people. 

```{r}
arrival_df <- data.frame(ID = c(1:1e6), times = rlnorm(1e6, meanlog = 3))
service <- rlnorm(1e6)
server_list <- as.server.step(c(1500,100000,150000),c(1,3,1,10))

# Output in time (seconds)
system.time(bigqueue1 <<- queue_step(arrival_df = arrival_df, service = service, servers = server_list))

```

Reordering takes a long time. Let's try the same situation with the arrivals ordered according to their arrival time. 

```{r}
ord <- order(arrival_df$times)
arrival_df$times <- arrival_df$times[ord]
service <- service[ord]

server_list <- as.server.step(c(1500,100000,150000),c(1,3,1,10))

# Output in time (seconds)
system.time(bigqueue2 <<- queue_step(arrival_df = arrival_df, service = service, servers = server_list))

all(bigqueue1$times == bigqueue2$times[order(ord)])

```

