---
title: "Using the `queuecomputer` package"
author: "Anthony Ebert"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# Introduction

The purpose of the package `queuecomputer` is to compute, deterministically, the output of a queue network given certain inputs. The most important functions are `queue_step`, `lag_step` and `wait_step`. An important case of a queueing network which can be modelled with these functions is that of an international airport terminal. 

When passengers arrive at the immigration desk to be processed this is a queue. If the arrival times of all customers as well as the time needed at the service desk are supplied then the departure times can be computed deterministically. The logic is implemented in the `queue_step` function where the user supplies the arrival times and service times as input. 

Passengers walking between queueing stages is modelled as a `lag_step`, where the service times are simply added to the arrival times. The departure times are equivalent to a `queue_step` with an excessive number of servers. 

Passengers waiting for bags at the baggage carousels is modelled with `wait_step`. The inputs are the arrival times of the bags and passengers, and the departure times is the vector of maximum times for each. 

# Input format

The first argument to the functions `queue_step`, `lag_step` and `wait_step` is a dataframe with a column of unique customer IDs labelled 'ID' and a column of arrival times labelled 'times'. For example:

```{r}
library(queuecomputer)

arrivals <- data.frame(ID = c(1:100), times = rlnorm(100, meanlog = 4))

head(arrivals)

service <- rlnorm(100)

departures <- queue_step(arrival_df = arrivals, service = service)

head(departures)
```

# Resourcing schedule

The resourcing schedule is specified with a list of step functions with range $\{0,1\}$, where 0 represents unavailable and 1 represents available. The `server_split` function was developed to make this easier to input: 

```{r}
resource_schedule <- server_split(c(10,50,100), c(0, 1, 3, 1))

resource_schedule

departures <- queue_step(arrival_df = arrivals, service = service, server_list = resource_schedule)

head(departures)
```

# Setting up a queue network

It is simple to set up a chain of queueing elements with `queuecomputer`. Suppose passengers must walk to a queue, then wait for service and then wait for their bags. 

```{r}
library(dplyr)
library(ggplot2)

set.seed(500)

arrivals <- data.frame(ID = c(1:100), times = rlnorm(100, meanlog = 2))
service_l <- rlnorm(100)
service_q <- rlnorm(100, meanlog = -1.5)
arrivals_b <- data.frame(ID = c(1:100), times = rlnorm(100, meanlog = 3))

# The queue elements can be computed one by one. 

departures_1 <- lag_step(arrivals, service_l)
departures_2 <- queue_step(departures_1, service = service_q)
departures_3 <- wait_step(departures_2, arrivals_b)

departure_df <- data.frame(arrival_times = arrivals$times, departures_1 = departures_1$times, departures_2 = departures_2$times, departures_3 = departures_3$times) %>% reshape2::melt()

qplot(value, data = departure_df, colour = variable, geom = "density") + xlab("time")

# The queue elements can be chained together with the magrittr package. 

departures <- lag_step(arrivals, service_l) %>% queue_step(service = service_q) %>% wait_step(arrivals_b)

# plot(density(arrivals$times, from = 0), xlim = c(0, 100))
# lines(density(departures_1$times, from = 0), col = "red")
# lines(density(departures_2$times, from = 0), col = "blue")
# lines(density(departures_3$times, from = 0), col = "green")

```



