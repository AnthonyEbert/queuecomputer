---
title: "Using the `queuecomputer` package"
author: "Anthony Ebert"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# Introduction

The purpose of the package `queuecomputer` is to compute, deterministically, the output of a queue network given certain inputs. The most important functions are `queue_step`, `lag_step` and `wait_step`. An important case of a queueing network which can be modelled with these functions is that of an international airport terminal. 

When passengers arrive at the immigration desk to be processed this is a queue. If the arrival times of all customers as well as the time needed at the service desk are supplied then the departure times can be computed deterministically. The logic is implemented in the `queue_step` function where the user supplies the arrival times and service times as input. 

Passengers walking between queueing stages is modelled as a `lag_step`, where the service times are simply added to the arrival times. The departure times are equivalent to a `queue_step` with an excessive number of servers. 

Passengers waiting for bags at the baggage carousels is modelled with `wait_step`. The inputs are the arrival times of the bags and passengers, and the departure times is the vector of maximum times for each. 

# Input format

The first argument to the functions `queue_step`, `lag_step` and `wait_step` is a dataframe with a column of unique customer IDs labelled 'ID' and a column of arrival times labelled 'times'. For example:

```{r}
library(queuecomputer)

arrivals <- data.frame(ID = c(1:100), times = cumsum(rexp(100)))

head(arrivals)

service <- rexp(100)

departures <- queue_step(arrival_df = arrivals, service = service)

head(departures)
```

# Resourcing schedule

The resourcing schedule is specified with either a non-zero natural number, a `quick.q` or a `server.list` object. Use a non-zero natural number when the number of servers does not change over time. The `quick.q` object is the default and is used when we don't care which particular servers are available, just how many are available at certain times. The computation speed for `queue_step()` is much faster when using a `quick.q` rather than a `server.list` input for the `servers` argument. 

We create a `quick.q` object with the `server.split()` function. 

```{r}
# Zero servers available before time 10
# One server available between time 10 and time 50
# Three servers available between time 50 and time 100
# One server available from time 100 onwards
resource_schedule <- server_split(c(10,50,100), c(0, 1, 3, 1))

resource_schedule

departures <- queue_step(arrival_df = arrivals, service = service, servers = resource_schedule)

head(departures)
```

The `server.list` object is a list of step functions which represent each server, the range is $\{0,1\}$, where 0 represents unavailable and 1 represents available and the knots represent the times where availability changes. 

The `as.server.list()` function is used to create a `server.list` object.

```{r}
# Server 1 is available before time 10.
# Server 2 is available between time 15 and time 30.
# Server 3 is available after time 10. 
as.server.list(list(10, c(15,30), 10), c(1,0,0))
```

# Setting up a queue network

It is simple to set up a chain of queueing elements with `queuecomputer`. Suppose passengers must walk to a queue, then wait for service and then wait for their bags. 

```{r}
library(ggplot2)
library(dplyr)

set.seed(500)

arrivals <- data.frame(ID = c(1:100), times = cumsum(rexp(100)))
service_l <- rexp(100, 0.8)
service_q <- rexp(100, 0.5)
arrivals_b <- data.frame(ID = c(1:100), times = cumsum(rexp(100, 0.8)))

# The queue elements can be computed one by one. 

departures_1 <- lag_step(arrivals, service_l)
departures_2 <- queue_step(departures_1, service = service_q, servers = 2)
departures_3 <- wait_step(departures_2, arrivals_b)

departure_df <- data.frame(arrival_times = arrivals$times, departures_1 = departures_1$times, departures_2 = departures_2$times, departures_3 = departures_3$times) %>% reshape2::melt()

qplot(value, data = departure_df, colour = variable, geom = "density") + xlab("time")

# The queue elements can be chained together with the %>% operator. 

departures <- lag_step(arrivals, service_l) %>% queue_step(service = service_q, servers = 2) %>% wait_step(arrivals_b)

all(departures$times == departures_3$times)

```



